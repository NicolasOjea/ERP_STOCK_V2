import {
  highlightResult,
  makeFilterProps,
  useFilter
} from "./chunk-OWVKKZL4.js";
import {
  VMenu,
  VVirtualScroll,
  makeSelectProps,
  useMenuActivator,
  useScrolling
} from "./chunk-6SAWRQDG.js";
import {
  VTextField,
  makeVTextFieldProps
} from "./chunk-KUCELMFX.js";
import {
  VList,
  VListItem,
  VListSubheader,
  useItems
} from "./chunk-4YGUD2IC.js";
import {
  VDivider
} from "./chunk-6NVUG6D4.js";
import {
  VChip
} from "./chunk-WMNJOMZH.js";
import {
  VAvatar
} from "./chunk-V4HOBQDQ.js";
import {
  VDefaultsProvider
} from "./chunk-OZDWFHBA.js";
import {
  VCheckboxBtn
} from "./chunk-IKBRYDCD.js";
import {
  useInputIcon
} from "./chunk-VDYCVUAF.js";
import {
  useForm
} from "./chunk-TH2INL7F.js";
import {
  VIcon
} from "./chunk-FOSGIXWT.js";
import {
  forwardRefs
} from "./chunk-BKGZARYA.js";
import {
  useTextColor
} from "./chunk-3QOL6ILH.js";
import {
  useLocale
} from "./chunk-J5FPDO3N.js";
import {
  useProxiedModel
} from "./chunk-HB4O5C76.js";
import {
  IN_BROWSER,
  checkPrintable,
  deepEqual,
  ensureValidVNode,
  genericComponent,
  matchesSelector,
  noop,
  omit,
  propsFactory,
  useRender,
  wrapInArray
} from "./chunk-SXDYE4G3.js";
import {
  Fragment,
  computed,
  createBaseVNode,
  createTextVNode,
  createVNode,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeStyle,
  ref,
  shallowRef,
  toRef,
  watch
} from "./chunk-MYEHH3VS.js";

// node_modules/vuetify/lib/components/VAutocomplete/VAutocomplete.js
import "C:/Users/Usuario/OneDrive/Desktop/programacion/ERP_STOCK_V2/frontend/pos-ui/node_modules/vuetify/lib/components/VAutocomplete/VAutocomplete.css";
var makeVAutocompleteProps = propsFactory({
  autoSelectFirst: {
    type: [Boolean, String]
  },
  clearOnSelect: Boolean,
  search: String,
  ...makeFilterProps({
    filterKeys: ["title"]
  }),
  ...makeSelectProps(),
  ...omit(makeVTextFieldProps({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty"])
}, "VAutocomplete");
var VAutocomplete = genericComponent()({
  name: "VAutocomplete",
  props: makeVAutocompleteProps(),
  emits: {
    "update:focused": (focused) => true,
    "update:search": (value) => true,
    "update:modelValue": (value) => true,
    "update:menu": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const isFocused = shallowRef(false);
    const isPristine = shallowRef(true);
    const listHasFocus = shallowRef(false);
    const vMenuRef = ref();
    const vVirtualScrollRef = ref();
    const selectionIndex = shallowRef(-1);
    const _searchLock = shallowRef(null);
    const {
      items,
      transformIn,
      transformOut
    } = useItems(props);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(() => {
      var _a;
      return (_a = vTextFieldRef.value) == null ? void 0 : _a.color;
    });
    const {
      InputIcon
    } = useInputIcon(props);
    const search = useProxiedModel(props, "search", "");
    const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(v === null ? [null] : wrapInArray(v)), (v) => {
      const transformed = transformOut(v);
      return props.multiple ? transformed : transformed[0] ?? null;
    });
    const counterValue = computed(() => {
      return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : model.value.length;
    });
    const form = useForm(props);
    const {
      filteredItems,
      getMatches
    } = useFilter(props, items, () => _searchLock.value ?? (isPristine.value ? "" : search.value));
    const displayItems = computed(() => {
      if (props.hideSelected && _searchLock.value === null) {
        return filteredItems.value.filter((filteredItem) => !model.value.some((s) => s.value === filteredItem.value));
      }
      return filteredItems.value;
    });
    const closableChips = toRef(() => props.closableChips && !form.isReadonly.value && !form.isDisabled.value);
    const hasChips = computed(() => !!(props.chips || slots.chip));
    const hasSelectionSlot = computed(() => hasChips.value || !!slots.selection);
    const selectedValues = computed(() => model.value.map((selection) => selection.props.value));
    const firstSelectableItem = computed(() => displayItems.value.find((x) => x.type === "item" && !x.props.disabled));
    const highlightFirst = computed(() => {
      var _a;
      const selectFirst = props.autoSelectFirst === true || props.autoSelectFirst === "exact" && search.value === ((_a = firstSelectableItem.value) == null ? void 0 : _a.title);
      return selectFirst && displayItems.value.length > 0 && !isPristine.value && !listHasFocus.value;
    });
    const menuDisabled = computed(() => props.hideNoData && !displayItems.value.length || form.isReadonly.value || form.isDisabled.value);
    const _menu = useProxiedModel(props, "menu");
    const menu = computed({
      get: () => _menu.value,
      set: (v) => {
        var _a;
        if (_menu.value && !v && ((_a = vMenuRef.value) == null ? void 0 : _a.Î¨openChildren.size)) return;
        if (v && menuDisabled.value) return;
        _menu.value = v;
      }
    });
    const {
      menuId,
      ariaExpanded,
      ariaControls
    } = useMenuActivator(props, menu);
    const listRef = ref();
    const listEvents = useScrolling(listRef, vTextFieldRef);
    function onClear(e) {
      if (props.openOnClear) {
        menu.value = true;
      }
      search.value = "";
    }
    function onMousedownControl() {
      if (menuDisabled.value) return;
      menu.value = true;
    }
    function onMousedownMenuIcon(e) {
      if (menuDisabled.value) return;
      if (isFocused.value) {
        e.preventDefault();
        e.stopPropagation();
      }
      menu.value = !menu.value;
    }
    function onListKeydown(e) {
      var _a;
      if (checkPrintable(e) || e.key === "Backspace") {
        (_a = vTextFieldRef.value) == null ? void 0 : _a.focus();
      }
    }
    function onKeydown(e) {
      var _a, _b, _c, _d, _e;
      if (form.isReadonly.value) return;
      const selectionStart = (_a = vTextFieldRef.value) == null ? void 0 : _a.selectionStart;
      const length = model.value.length;
      if (["Enter", "ArrowDown", "ArrowUp"].includes(e.key)) {
        e.preventDefault();
      }
      if (["Enter", "ArrowDown"].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape"].includes(e.key)) {
        menu.value = false;
      }
      if (highlightFirst.value && ["Enter", "Tab"].includes(e.key) && firstSelectableItem.value && !model.value.some((_ref2) => {
        let {
          value
        } = _ref2;
        return value === firstSelectableItem.value.value;
      })) {
        select(firstSelectableItem.value);
      }
      if (e.key === "ArrowDown" && highlightFirst.value) {
        (_b = listRef.value) == null ? void 0 : _b.focus("next");
      }
      if (["Backspace", "Delete"].includes(e.key)) {
        if (!props.multiple && hasSelectionSlot.value && model.value.length > 0 && !search.value) return select(model.value[0], false);
        if (~selectionIndex.value) {
          e.preventDefault();
          const originalSelectionIndex = selectionIndex.value;
          select(model.value[selectionIndex.value], false);
          selectionIndex.value = originalSelectionIndex >= length - 1 ? length - 2 : originalSelectionIndex;
        } else if (e.key === "Backspace" && !search.value) {
          selectionIndex.value = length - 1;
        }
        return;
      }
      if (!props.multiple) return;
      if (e.key === "ArrowLeft") {
        if (selectionIndex.value < 0 && selectionStart && selectionStart > 0) return;
        const prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
        if (model.value[prev]) {
          selectionIndex.value = prev;
        } else {
          const searchLength = ((_c = search.value) == null ? void 0 : _c.length) ?? null;
          selectionIndex.value = -1;
          (_d = vTextFieldRef.value) == null ? void 0 : _d.setSelectionRange(searchLength, searchLength);
        }
      } else if (e.key === "ArrowRight") {
        if (selectionIndex.value < 0) return;
        const next = selectionIndex.value + 1;
        if (model.value[next]) {
          selectionIndex.value = next;
        } else {
          selectionIndex.value = -1;
          (_e = vTextFieldRef.value) == null ? void 0 : _e.setSelectionRange(0, 0);
        }
      } else if (~selectionIndex.value && checkPrintable(e)) {
        selectionIndex.value = -1;
      }
    }
    function onChange(e) {
      if (matchesSelector(vTextFieldRef.value, ":autofill") || matchesSelector(vTextFieldRef.value, ":-webkit-autofill")) {
        const item = items.value.find((item2) => item2.title === e.target.value);
        if (item) {
          select(item);
        }
      }
    }
    function onAfterEnter() {
      var _a;
      if (props.eager) {
        (_a = vVirtualScrollRef.value) == null ? void 0 : _a.calculateVisibleItems();
      }
    }
    function onAfterLeave() {
      var _a;
      if (isFocused.value) {
        isPristine.value = true;
        (_a = vTextFieldRef.value) == null ? void 0 : _a.focus();
      }
      _searchLock.value = null;
    }
    function onFocusin(e) {
      isFocused.value = true;
      setTimeout(() => {
        listHasFocus.value = true;
      });
    }
    function onFocusout(e) {
      listHasFocus.value = false;
    }
    function onUpdateModelValue(v) {
      if (v == null || v === "" && !props.multiple && !hasSelectionSlot.value) model.value = [];
    }
    const isSelecting = shallowRef(false);
    function select(item) {
      let set = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (!item || item.props.disabled) return;
      if (props.multiple) {
        const index = model.value.findIndex((selection) => (props.valueComparator || deepEqual)(selection.value, item.value));
        const add = set == null ? !~index : set;
        if (~index) {
          const value = add ? [...model.value, item] : [...model.value];
          value.splice(index, 1);
          model.value = value;
        } else if (add) {
          model.value = [...model.value, item];
        }
        if (props.clearOnSelect) {
          search.value = "";
        }
      } else {
        const add = set !== false;
        model.value = add ? [item] : [];
        _searchLock.value = isPristine.value ? "" : search.value ?? "";
        search.value = add && !hasSelectionSlot.value ? item.title : "";
        nextTick(() => {
          menu.value = false;
          isPristine.value = true;
        });
      }
    }
    watch(isFocused, (val, oldVal) => {
      var _a;
      if (val === oldVal) return;
      if (val) {
        isSelecting.value = true;
        search.value = props.multiple || hasSelectionSlot.value ? "" : String(((_a = model.value.at(-1)) == null ? void 0 : _a.props.title) ?? "");
        isPristine.value = true;
        nextTick(() => isSelecting.value = false);
      } else {
        if (!props.multiple && search.value == null) model.value = [];
        menu.value = false;
        if (!isPristine.value && search.value) {
          _searchLock.value = search.value;
        }
        search.value = "";
        selectionIndex.value = -1;
      }
    });
    watch(search, (val) => {
      if (!isFocused.value || isSelecting.value) return;
      if (val) menu.value = true;
      isPristine.value = !val;
    });
    watch(menu, (val) => {
      if (!props.hideSelected && val && model.value.length && isPristine.value) {
        const index = displayItems.value.findIndex((item) => model.value.some((s) => item.value === s.value));
        IN_BROWSER && window.requestAnimationFrame(() => {
          var _a;
          index >= 0 && ((_a = vVirtualScrollRef.value) == null ? void 0 : _a.scrollToIndex(index));
        });
      }
      if (val) _searchLock.value = null;
    });
    watch(items, (newVal, oldVal) => {
      if (menu.value) return;
      if (isFocused.value && !oldVal.length && newVal.length) {
        menu.value = true;
      }
    });
    useRender(() => {
      const hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
      const isDirty = model.value.length > 0;
      const textFieldProps = VTextField.filterProps(props);
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef
      }, textFieldProps, {
        "modelValue": search.value,
        "onUpdate:modelValue": [($event) => search.value = $event, onUpdateModelValue],
        "focused": isFocused.value,
        "onUpdate:focused": ($event) => isFocused.value = $event,
        "validationValue": model.externalValue,
        "counterValue": counterValue.value,
        "dirty": isDirty,
        "onChange": onChange,
        "class": ["v-autocomplete", `v-autocomplete--${props.multiple ? "multiple" : "single"}`, {
          "v-autocomplete--active-menu": menu.value,
          "v-autocomplete--chips": !!props.chips,
          "v-autocomplete--selection-slot": !!hasSelectionSlot.value,
          "v-autocomplete--selecting-index": selectionIndex.value > -1
        }, props.class],
        "style": props.style,
        "readonly": form.isReadonly.value,
        "placeholder": isDirty ? void 0 : props.placeholder,
        "onClick:clear": onClear,
        "onMousedown:control": onMousedownControl,
        "onKeydown": onKeydown,
        "aria-expanded": ariaExpanded.value,
        "aria-controls": ariaControls.value
      }), {
        ...slots,
        default: (_ref3) => {
          let {
            id
          } = _ref3;
          return createBaseVNode(Fragment, null, [createVNode(VMenu, mergeProps({
            "id": menuId.value,
            "ref": vMenuRef,
            "modelValue": menu.value,
            "onUpdate:modelValue": ($event) => menu.value = $event,
            "activator": "parent",
            "contentClass": "v-autocomplete__content",
            "disabled": menuDisabled.value,
            "eager": props.eager,
            "maxHeight": 310,
            "openOnClick": false,
            "closeOnContentClick": false,
            "onAfterEnter": onAfterEnter,
            "onAfterLeave": onAfterLeave
          }, props.menuProps), {
            default: () => [hasList && createVNode(VList, mergeProps({
              "ref": listRef,
              "filterable": true,
              "selected": selectedValues.value,
              "selectStrategy": props.multiple ? "independent" : "single-independent",
              "onMousedown": (e) => e.preventDefault(),
              "onKeydown": onListKeydown,
              "onFocusin": onFocusin,
              "onFocusout": onFocusout,
              "tabindex": "-1",
              "selectable": !!displayItems.value.length,
              "aria-live": "polite",
              "aria-labelledby": `${id.value}-label`,
              "aria-multiselectable": props.multiple,
              "color": props.itemColor ?? props.color
            }, listEvents, props.listProps), {
              default: () => {
                var _a, _b, _c;
                return [(_a = slots["prepend-item"]) == null ? void 0 : _a.call(slots), !displayItems.value.length && !props.hideNoData && (((_b = slots["no-data"]) == null ? void 0 : _b.call(slots)) ?? createVNode(VListItem, {
                  "key": "no-data",
                  "title": t(props.noDataText)
                }, null)), createVNode(VVirtualScroll, {
                  "ref": vVirtualScrollRef,
                  "renderless": true,
                  "items": displayItems.value,
                  "itemKey": "value"
                }, {
                  default: (_ref4) => {
                    var _a2, _b2, _c2;
                    let {
                      item,
                      index,
                      itemRef
                    } = _ref4;
                    const itemProps = mergeProps(item.props, {
                      ref: itemRef,
                      key: item.value,
                      active: highlightFirst.value && item === firstSelectableItem.value ? true : void 0,
                      onClick: () => select(item, null),
                      "aria-posinset": index + 1,
                      "aria-setsize": displayItems.value.length
                    });
                    if (item.type === "divider") {
                      return ((_a2 = slots.divider) == null ? void 0 : _a2.call(slots, {
                        props: item.raw,
                        index
                      })) ?? createVNode(VDivider, mergeProps(item.props, {
                        "key": `divider-${index}`
                      }), null);
                    }
                    if (item.type === "subheader") {
                      return ((_b2 = slots.subheader) == null ? void 0 : _b2.call(slots, {
                        props: item.raw,
                        index
                      })) ?? createVNode(VListSubheader, mergeProps(item.props, {
                        "key": `subheader-${index}`
                      }), null);
                    }
                    return ((_c2 = slots.item) == null ? void 0 : _c2.call(slots, {
                      item,
                      index,
                      props: itemProps
                    })) ?? createVNode(VListItem, mergeProps(itemProps, {
                      "role": "option"
                    }), {
                      prepend: (_ref5) => {
                        let {
                          isSelected
                        } = _ref5;
                        return createBaseVNode(Fragment, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                          "key": item.value,
                          "modelValue": isSelected,
                          "ripple": false,
                          "tabindex": "-1",
                          "aria-hidden": true,
                          "onClick": (event) => event.preventDefault()
                        }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                          "image": item.props.prependAvatar
                        }, null), item.props.prependIcon && createVNode(VIcon, {
                          "icon": item.props.prependIcon
                        }, null)]);
                      },
                      title: () => {
                        var _a3;
                        return isPristine.value ? item.title : highlightResult("v-autocomplete", item.title, (_a3 = getMatches(item)) == null ? void 0 : _a3.title);
                      }
                    });
                  }
                }), (_c = slots["append-item"]) == null ? void 0 : _c.call(slots)];
              }
            })]
          }), model.value.map((item, index) => {
            function onChipClose(e) {
              e.stopPropagation();
              e.preventDefault();
              select(item, false);
            }
            const slotProps = mergeProps(VChip.filterProps(item.props), {
              "onClick:close": onChipClose,
              onKeydown(e) {
                if (e.key !== "Enter" && e.key !== " ") return;
                e.preventDefault();
                e.stopPropagation();
                onChipClose(e);
              },
              onMousedown(e) {
                e.preventDefault();
                e.stopPropagation();
              },
              modelValue: true,
              "onUpdate:modelValue": void 0
            });
            const hasSlot = hasChips.value ? !!slots.chip : !!slots.selection;
            const slotContent = hasSlot ? ensureValidVNode(hasChips.value ? slots.chip({
              item,
              index,
              props: slotProps
            }) : slots.selection({
              item,
              index
            })) : void 0;
            if (hasSlot && !slotContent) return void 0;
            return createBaseVNode("div", {
              "key": item.value,
              "class": normalizeClass(["v-autocomplete__selection", index === selectionIndex.value && ["v-autocomplete__selection--selected", textColorClasses.value]]),
              "style": normalizeStyle(index === selectionIndex.value ? textColorStyles.value : {})
            }, [hasChips.value ? !slots.chip ? createVNode(VChip, mergeProps({
              "key": "chip",
              "closable": closableChips.value,
              "size": "small",
              "text": item.title,
              "disabled": item.props.disabled
            }, slotProps), null) : createVNode(VDefaultsProvider, {
              "key": "chip-defaults",
              "defaults": {
                VChip: {
                  closable: closableChips.value,
                  size: "small",
                  text: item.title
                }
              }
            }, {
              default: () => [slotContent]
            }) : slotContent ?? createBaseVNode("span", {
              "class": "v-autocomplete__selection-text"
            }, [item.title, props.multiple && index < model.value.length - 1 && createBaseVNode("span", {
              "class": "v-autocomplete__selection-comma"
            }, [createTextVNode(",")])])]);
          })]);
        },
        "append-inner": function() {
          var _a, _b;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createBaseVNode(Fragment, null, [(_a = slots["append-inner"]) == null ? void 0 : _a.call(slots, ...args), props.menuIcon ? createVNode(VIcon, {
            "class": "v-autocomplete__menu-icon",
            "color": (_b = vTextFieldRef.value) == null ? void 0 : _b.fieldIconColor,
            "icon": props.menuIcon,
            "onMousedown": onMousedownMenuIcon,
            "onClick": noop,
            "aria-hidden": true,
            "tabindex": "-1"
          }, null) : void 0, props.appendInnerIcon && createVNode(InputIcon, {
            "key": "append-icon",
            "name": "appendInner",
            "color": args[0].iconColor.value
          }, null)]);
        }
      });
    });
    return forwardRefs({
      isFocused,
      isPristine,
      menu,
      search,
      filteredItems,
      select
    }, vTextFieldRef);
  }
});

export {
  VAutocomplete
};
//# sourceMappingURL=chunk-WCBHD3ER.js.map
